{"version":3,"sources":["request.js"],"names":["MeetingRequest","request","api","API","LOCUS","resource","RESOURCE","LOCI","then","res","determineRedirections","body","catch","error","LoggerProxy","logger","responseBody","remoteLocusClusterUrls","length","all","map","url","method","HTTP_VERBS","GET","runWhitelistedDomains","loci","concat","locusUrls","resolve","StatelessWebexPlugin"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;;AACA;;;;;;AAMA;;;IAGqBA,c;;;;;;;;;;;;;AACnB;;;;wCAIoB;AAAA;;AAClB,aAAO,KAAKC,OAAL,CAAa;AAClBC,QAAAA,GAAG,EAAEC,eAAIC,KADS;AAElBC,QAAAA,QAAQ,EAAEC,oBAASC;AAFD,OAAb,EAIJC,IAJI,CAIC,UAACC,GAAD;AAAA,eAAS,KAAI,CAACC,qBAAL,CAA2BD,GAAG,CAACE,IAA/B,CAAT;AAAA,OAJD,EAKJC,KALI,CAKE,UAACC,KAAD,EAAW;AAChBC,6BAAYC,MAAZ,CAAmBF,KAAnB,+EAAgGA,KAAhG;AACD,OAPI,CAAP;AAQD,K,CAED;;AAEA;;;;;;;;0CAKsBG,Y,EAAc;AAAA;;AAClC,UAAIA,YAAY,CAACC,sBAAb,IAAuCD,YAAY,CAACC,sBAAb,CAAoCC,MAA/E,EAAuF;AACrF,eAAO,iBAAQC,GAAR,CAAYH,YAAY,CAACC,sBAAb,CAAoCG,GAApC,CAAwC,UAACC,GAAD;AAAA,iBAAS,MAAI,CAACpB,OAAL,CAAa;AAC/EqB,YAAAA,MAAM,EAAEC,sBAAWC,GAD4D;AAE/EH,YAAAA,GAAG,EAAHA,GAF+E;AAG/EI,YAAAA,qBAAqB,EAAE,IAHwD,CAGnD;;AAHmD,WAAb,EAKjEjB,IALiE,CAK5D,UAACC,GAAD,EAAS;AACbO,YAAAA,YAAY,CAACU,IAAb,GAAoBV,YAAY,CAACU,IAAb,CAAkBC,MAAlB,CAAyBlB,GAAG,CAACE,IAAJ,CAASe,IAAlC,CAApB;AACAV,YAAAA,YAAY,CAACY,SAAb,GAAyBZ,YAAY,CAACY,SAAb,CAAuBD,MAAvB,CAA8BlB,GAAG,CAACE,IAAJ,CAASiB,SAAvC,CAAzB;AAEA,mBAAO,iBAAQC,OAAR,CAAgBb,YAAhB,CAAP;AACD,WAViE,EAWjEJ,KAXiE,CAW3D,UAACC,KAAD,EAAW;AAChBC,iCAAYC,MAAZ,CAAmBF,KAAnB,4FAA6GQ,GAA7G,uBAA6HR,KAA7H;AACD,WAbiE,CAAT;AAAA,SAAxC,CAAZ,EAcJL,IAdI,CAcC;AAAA,iBAAM,iBAAQqB,OAAR,CAAgBb,YAAhB,CAAN;AAAA,SAdD,CAAP;AAeD;;AAED,aAAO,iBAAQa,OAAR,CAAgBb,YAAhB,CAAP;AACD;;;EA3CyCc,+B","sourcesContent":["import {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  HTTP_VERBS,\n  API,\n  RESOURCE\n} from '../constants';\n\n/**\n * @class MeetingRequest\n */\nexport default class MeetingRequest extends StatelessWebexPlugin {\n  /**\n     *  get all the active meetings for the user\n     * @returns {Array} return locus array\n    */\n  getActiveMeetings() {\n    return this.request({\n      api: API.LOCUS,\n      resource: RESOURCE.LOCI\n    })\n      .then((res) => this.determineRedirections(res.body))\n      .catch((error) => {\n        LoggerProxy.logger.error(`Meetings:request#getActiveMeetings --> failed to get locus details, ${error}`);\n      });\n  }\n\n  // locus federation, determines and populate locus if the responseBody has remote URLs to fetch locus details\n\n  /**\n   *  Fetches indivdual locus rather then getting all at once\n   * @param {object} responseBody determine the locus and fetch them if a remoteUrl is given\n   * @returns {Promise}  returns locusObject array\n   */\n  determineRedirections(responseBody) {\n    if (responseBody.remoteLocusClusterUrls && responseBody.remoteLocusClusterUrls.length) {\n      return Promise.all(responseBody.remoteLocusClusterUrls.map((url) => this.request({\n        method: HTTP_VERBS.GET,\n        url,\n        runWhitelistedDomains: true // allows auth token for whitelisted domain\n      })\n        .then((res) => {\n          responseBody.loci = responseBody.loci.concat(res.body.loci);\n          responseBody.locusUrls = responseBody.locusUrls.concat(res.body.locusUrls);\n\n          return Promise.resolve(responseBody);\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Meetings:request#determineRedirections --> failed to get locus details from url: ${url}, reason: ${error}`);\n        })))\n        .then(() => Promise.resolve(responseBody));\n    }\n\n    return Promise.resolve(responseBody);\n  }\n}\n"]}