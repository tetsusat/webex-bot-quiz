"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _constants = require("../constants");

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

/* globals window */
var MeetingsUtil = {};

MeetingsUtil.extractDestination = function (destination, type) {
  var dest = destination;

  if (type === _constants._LOCUS_ID_) {
    if (!(destination && destination.url)) {
      throw new _parameter.default('You cannot create a meeting by locus without a locus.url defined');
    }

    dest = destination.url;
  }

  return dest;
}; // ** This is a workaround to fix Firefox and google android not downloading H264 codec on start


MeetingsUtil.triggerH264Codec = /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
  var testPeerconnection;
  return _regenerator.default.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          testPeerconnection = new window.RTCPeerConnection();
          _context.next = 4;
          return testPeerconnection.createOffer();

        case 4:
          testPeerconnection.close();
          testPeerconnection = null;
          _context.next = 11;
          break;

        case 8:
          _context.prev = 8;
          _context.t0 = _context["catch"](0);

          _loggerProxy.default.logger.info('Meetings:util#triggerH264Codec --> cannot trigger H264 codec download');

        case 11:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, null, [[0, 8]]);
}));

MeetingsUtil.getMeetingAddedType = function (type) {
  return type === _constants._LOCUS_ID_ ? _constants._INCOMING_ : _constants._CREATED_;
};

MeetingsUtil.handleRoapMercury = function (envelope, meetingCollection) {
  var data = envelope.data;
  var eventType = data.eventType;

  if (eventType === _constants.LOCUSEVENT.MESSAGE_ROAP) {
    var meeting = meetingCollection.getByKey(_constants.CORRELATION_ID, data.correlationId);

    if (meeting) {
      meeting.roap.roapEvent(data);
    }
  }
};

MeetingsUtil.checkForCorrelationId = function (deviceUrl, locus) {
  var devices = [];

  if (locus) {
    if (locus && locus.self && locus.self.devices) {
      devices = locus.self.devices;
    }

    var foundDevice = devices.find(function (device) {
      return device.url === deviceUrl;
    });

    if (foundDevice && foundDevice.correlationId) {
      return foundDevice.correlationId;
    }
  }

  return false;
};

var _default = MeetingsUtil;
exports.default = _default;
//# sourceMappingURL=util.js.map
