{"version":3,"sources":["parser.js"],"names":["Parser","updateWithDeltaLocus","deltaLocus","meeting","sequence","rangeStart","rangeEnd","entries","locusInfo","baseSequence","meetingRequest","getFullLocus","desync","locusUrl","then","res","body","onFullLocus","DELTAEVENT","EQ","resBase","LocusUtil","compareLocus","GT","syncUrl","LT","CF","fullState","state","LOCUS","STATE","INITIALIZING","length","locusDesync","needToGetFullLocus","generateSyncDebugFlag","syncMeeting","onDeltaLocus","INACTIVE"],"mappings":"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","sourcesContent":["import {min} from 'lodash';\n\nimport LocusUtil from '../locus-info/utils';\nimport {DELTAEVENT, LOCUS} from '../constants';\n\nconst Parser = {};\n\n// https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\nParser.updateWithDeltaLocus = (deltaLocus, meeting) => {\n  if (!(deltaLocus.sequence && (deltaLocus.sequence.rangeStart <= deltaLocus.sequence.rangeEnd) && (deltaLocus.sequence.rangeEnd <= min(deltaLocus.sequence.entries)))) {\n    return null;\n  }\n\n  // Its a new meeting and has incomplete information\n  if (!meeting.locusInfo.baseSequence) {\n    return meeting.meetingRequest.getFullLocus({\n      desync: true,\n      locusUrl: meeting.locusUrl\n    }).then((res) => {\n      if (res && res.body) {\n        res.body.baseSequence = deltaLocus.baseSequence; // TODO: verify baseSequence age and update as necessary\n        meeting.locusInfo.onFullLocus(res.body);\n      }\n\n      // Sending EQ if there is an error as next request will fixe it\n      return DELTAEVENT.EQ;\n    });\n  }\n\n  // THIS IS A NEW MEETING OBJECT\n  // // If meeting has no sequence, it means just initialized and will apply whatever in locus DTO\n  // if (isNewMeeting || !this.locus.sequence) {\n  //   meeting._updateWithDeltaLocus(deltaLocus, emitter);\n  //   meeting.locusDesync = false;\n  //   meeting.needToGetFullLocus = false;\n  //   return DELTAEVENT.GT;\n  // }\n\n  if (!deltaLocus.sequence) {\n    // TODO: force update\n  }\n\n  // TODO: If this was the first event, the client will not have a syncURL\n  // in its working copy to do a GET on. In this case clients should do a GET on locusUrl contained in the DTO\n\n  let res;\n  let resBase;\n\n  res = LocusUtil.compareLocus(deltaLocus.sequence, meeting.locusInfo.sequence);\n  // In-coming locus is greater than working copy, need to compare with base if there\n  // is base sequence except the first delta locus event\n  if (res === DELTAEVENT.GT && deltaLocus.baseSequence && meeting.locusInfo.syncUrl) {\n    resBase = LocusUtil.compareLocus(deltaLocus.baseSequence, meeting.locusInfo.sequence);\n    if (resBase === DELTAEVENT.LT || resBase === DELTAEVENT.CF) {\n      res = DELTAEVENT.CF;\n    }\n  }\n  // Special case for OBTP with meeting size equal or over 5. Locus might change this later\n  // This is a temporary fix. I will find a better solution later.\n  if (!deltaLocus.baseSequence && res === DELTAEVENT.EQ && deltaLocus.fullState.state === LOCUS.STATE.INITIALIZING &&\n        deltaLocus.sequence.rangeStart === 0 && deltaLocus.sequence.rangeEnd === 0 &&\n        deltaLocus.sequence.entries.length === 0) {\n    res = DELTAEVENT.GT;\n  }\n  switch (res) {\n    case DELTAEVENT.LT:\n    case DELTAEVENT.EQ:\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n    case DELTAEVENT.CF:\n      LocusUtil.generateSyncDebugFlag(meeting, deltaLocus);\n      if (meeting.locusDesync) {\n        meeting.meetingRequest.getFullLocus({\n          desync: true,\n          locusUrl: meeting.locusUrl\n        }).then((res) => {\n          meeting.locusInfo.onFullLocus(res.body);\n        });\n      }\n      else {\n        meeting.locusDesync = true;\n        Parser.syncMeeting(meeting, deltaLocus);\n      }\n      break;\n    case DELTAEVENT.GT:\n      meeting.locusInfo.onDeltaLocus(deltaLocus);\n      // Turn off desync in case this delta locus comes from a sync request\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n    default:\n  }\n\n  return res;\n};\n\n\nParser.syncMeeting = (meeting, deltaLocus) => {\n  if (meeting &&\n        meeting.locusInfo &&\n        meeting.locusInfo.syncUrl &&\n        meeting.locusInfo.fullState &&\n        meeting.locusInfo.fullState.state !== LOCUS.STATE.INACTIVE) {\n    // found that the locus syncs were happening even after 4 hrs of meeting\n    // completion, resulting in 403 errors. This check ensures we call\n    // syncing only if the locus state is not INACTIVE.\n    meeting.meetingRequest.syncMeeting({\n      syncUrl: deltaLocus.syncUrl,\n      desync: meeting.desync\n    })\n      .then((res) => {\n        meeting.locusInfo.onDeltaLocus(res.body);\n      });\n  }\n};\n\nexport default Parser;\n"]}