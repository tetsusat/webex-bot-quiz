"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _min2 = _interopRequireDefault(require("lodash/min"));

var _utils = _interopRequireDefault(require("../locus-info/utils"));

var _constants = require("../constants");

var Parser = {}; // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events

Parser.updateWithDeltaLocus = function (deltaLocus, meeting) {
  if (!(deltaLocus.sequence && deltaLocus.sequence.rangeStart <= deltaLocus.sequence.rangeEnd && deltaLocus.sequence.rangeEnd <= (0, _min2.default)(deltaLocus.sequence.entries))) {
    return null;
  } // Its a new meeting and has incomplete information


  if (!meeting.locusInfo.baseSequence) {
    return meeting.meetingRequest.getFullLocus({
      desync: true,
      locusUrl: meeting.locusUrl
    }).then(function (res) {
      if (res && res.body) {
        res.body.baseSequence = deltaLocus.baseSequence; // TODO: verify baseSequence age and update as necessary

        meeting.locusInfo.onFullLocus(res.body);
      } // Sending EQ if there is an error as next request will fixe it


      return _constants.DELTAEVENT.EQ;
    });
  } // THIS IS A NEW MEETING OBJECT
  // // If meeting has no sequence, it means just initialized and will apply whatever in locus DTO
  // if (isNewMeeting || !this.locus.sequence) {
  //   meeting._updateWithDeltaLocus(deltaLocus, emitter);
  //   meeting.locusDesync = false;
  //   meeting.needToGetFullLocus = false;
  //   return DELTAEVENT.GT;
  // }


  if (!deltaLocus.sequence) {// TODO: force update
  } // TODO: If this was the first event, the client will not have a syncURL
  // in its working copy to do a GET on. In this case clients should do a GET on locusUrl contained in the DTO


  var res;
  var resBase;
  res = _utils.default.compareLocus(deltaLocus.sequence, meeting.locusInfo.sequence); // In-coming locus is greater than working copy, need to compare with base if there
  // is base sequence except the first delta locus event

  if (res === _constants.DELTAEVENT.GT && deltaLocus.baseSequence && meeting.locusInfo.syncUrl) {
    resBase = _utils.default.compareLocus(deltaLocus.baseSequence, meeting.locusInfo.sequence);

    if (resBase === _constants.DELTAEVENT.LT || resBase === _constants.DELTAEVENT.CF) {
      res = _constants.DELTAEVENT.CF;
    }
  } // Special case for OBTP with meeting size equal or over 5. Locus might change this later
  // This is a temporary fix. I will find a better solution later.


  if (!deltaLocus.baseSequence && res === _constants.DELTAEVENT.EQ && deltaLocus.fullState.state === _constants.LOCUS.STATE.INITIALIZING && deltaLocus.sequence.rangeStart === 0 && deltaLocus.sequence.rangeEnd === 0 && deltaLocus.sequence.entries.length === 0) {
    res = _constants.DELTAEVENT.GT;
  }

  switch (res) {
    case _constants.DELTAEVENT.LT:
    case _constants.DELTAEVENT.EQ:
      meeting.locusDesync = false;
      meeting.needToGetFullLocus = false;
      break;

    case _constants.DELTAEVENT.CF:
      _utils.default.generateSyncDebugFlag(meeting, deltaLocus);

      if (meeting.locusDesync) {
        meeting.meetingRequest.getFullLocus({
          desync: true,
          locusUrl: meeting.locusUrl
        }).then(function (res) {
          meeting.locusInfo.onFullLocus(res.body);
        });
      } else {
        meeting.locusDesync = true;
        Parser.syncMeeting(meeting, deltaLocus);
      }

      break;

    case _constants.DELTAEVENT.GT:
      meeting.locusInfo.onDeltaLocus(deltaLocus); // Turn off desync in case this delta locus comes from a sync request

      meeting.locusDesync = false;
      meeting.needToGetFullLocus = false;
      break;

    default:
  }

  return res;
};

Parser.syncMeeting = function (meeting, deltaLocus) {
  if (meeting && meeting.locusInfo && meeting.locusInfo.syncUrl && meeting.locusInfo.fullState && meeting.locusInfo.fullState.state !== _constants.LOCUS.STATE.INACTIVE) {
    // found that the locus syncs were happening even after 4 hrs of meeting
    // completion, resulting in 403 errors. This check ensures we call
    // syncing only if the locus state is not INACTIVE.
    meeting.meetingRequest.syncMeeting({
      syncUrl: deltaLocus.syncUrl,
      desync: meeting.desync
    }).then(function (res) {
      meeting.locusInfo.onDeltaLocus(res.body);
    });
  }
};

var _default = Parser;
exports.default = _default;
//# sourceMappingURL=parser.js.map
