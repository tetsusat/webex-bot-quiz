"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty2 = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _util = _interopRequireDefault(require("util"));

var _bowser = _interopRequireDefault(require("bowser"));

var _uuid = _interopRequireDefault(require("uuid"));

var _window = _interopRequireDefault(require("global/window"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var _config = _interopRequireDefault(require("../common/config"));

var _config2 = require("./config");

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { ownKeys(Object(source)).forEach(function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

/**
 * @description Metrics handles all the call metrics events
 * @export
 * @class Metrics
 */
var Metrics = /*#__PURE__*/function () {
  /**
     * Create Metrics Object
     * @constructor
     * @public
     * @memberof Meetings
     */
  function Metrics() {
    (0, _classCallCheck2.default)(this, Metrics);

    if (!Metrics.instance) {
      /**
       * @instance
       * @type {Array}
       * @private
       * @memberof Metrics
       */
      this._events = [];
      /**
      * @instance
      * @type {MeetingCollection}
      * @private
      * @memberof Metrics
      */

      this.meetingCollection = null;
      /**
      * @instance
      * @type {MeetingCollection}
      * @private
      * @memberof Metrics
      */

      this.keys = (0, _values.default)(_config2.eventType);
      /**
       * @instance
       * @type {Metrics}
       * @private
       * @memberof Metrics
       */

      Metrics.instance = this;
    }

    return Metrics.instance;
  }
  /**
   * Initializes the Metrics singleton with a meeting Collection.
   *
   * @param {Object} meetingCollection meetings object
   * @param {Object} webex  webex SDK object
   *
   * @returns {void}
   */


  (0, _createClass2.default)(Metrics, [{
    key: "initialSetup",
    value: function initialSetup(meetingCollection, webex) {
      this.meetingCollection = meetingCollection;
      this.webex = webex;
    }
    /**
     * poste Meeting event metrics
     * @param {object} options {meetingId/meeting} as a json object
     * @param {String} options.meetingId
     * @param {object} options.data
     * @param {object} options.event
     * @returns {object} null
     */

  }, {
    key: "postEvent",
    value: function postEvent(options) {
      var meetingId = options.meetingId,
          _options$data = options.data,
          data = _options$data === void 0 ? {} : _options$data,
          event = options.event;
      var meeting = options.meeting;

      if (this.keys.indexOf(event) === -1) {
        _loggerProxy.default.logger.error("Metrics:index#postEvent --> Event ".concat(event, " doesn't exist in dictionary"));
      }

      if (!meeting && meetingId) {
        meeting = this.meetingCollection.get(meetingId);
      }

      if (meeting) {
        if (!meeting.callEvents) {
          meeting.callEvents = [];
        }

        if (event === _config2.eventType.MEDIA_QUALITY) {
          data.event = event;
          meeting.sendMediaQualityAnalyzerMetrics(data);
        } else {
          meeting.callEvents.push(event);
          data.event = event;
          meeting.sendCallAnalyzerMetrics(data);
        }
      } else {
        _loggerProxy.default.logger.info("Metrics:index#postEvent --> Event received for meetingId:".concat(meetingId, ", but meeting not found in collection."));
      }
    }
    /**
     *  Docs for Call analyzer metrics
    *   https://sqbu-github.cisco.com/WebExSquared/call-analyzer/wiki
    *   https://sqbu-github.cisco.com/WebExSquared/event-dictionary/blob/master/diagnostic-events.raml
    */

  }, {
    key: "initPayload",
    value: function initPayload(eventType, identifiers, options) {
      var payload = {
        eventId: _uuid.default.v4(),
        version: 1,
        origin: {
          buildType: 'prod',
          name: 'endpoint',
          networkType: 'unknown',
          userAgent: this.userAgentToString(),
          clientInfo: {
            clientType: options.clientType,
            os: 'linux',
            // TODO: BUG AND DOESNT ACCEPT OSNAME ON CA -> bowser.osname || 'null'
            osVersion: _bowser.default.osVersion || 'unknown',
            subClientType: options.subClientType
          }
        },
        originTime: {
          triggered: new Date().toISOString()
        },
        event: {
          name: eventType,
          canProceed: true,
          identifiers: identifiers,
          eventData: {
            webClientDomain: _window.default.location.hostname
          }
        }
      }; // TODO: more options should be checked and some of them should be mandatory in certain conditions

      if (options) {
        if (Object.prototype.hasOwnProperty.call(options, 'canProceed')) {
          payload.event.canProceed = options.canProceed;
        }

        if (options.errors) {
          payload.event.errors = options.errors;
        }

        if (options.mediaType) {
          payload.event.mediaType = options.mediaType;
        }

        if (options.trigger) {
          payload.event.trigger = options.trigger;
        }

        if (options.pstnAudioType) {
          payload.event.pstnAudioType = options.pstnAudioType;
        }

        if (options.mediaCapabilities) {
          payload.event.mediaCapabilities = options.mediaCapabilities;
        }

        if (options.recoveredBy) {
          payload.event.recoveredBy = options.recoveredBy;
        }
      }

      return payload;
    }
  }, {
    key: "osName",
    value: function osName() {
      // TODO: BUG AND DOESNT ACCEPT OSNAME ON CA -> bowser.osname || 'null'
      return 'mac';
    }
    /**
     * get the payload specific for a media quality event through call analyzer
     * @param {String} eventType the event name
     * @param {Object} identifiers contains the identifiers needed for CA
     * @param {String} identifiers.correlationId
     * @param {String} identifiers.locusUrl
     * @param {String} identifiers.locusId
     * @param {Object} options
     * @param {Object} options.intervalData
     * @param {String} options.clientType
     * @returns {Object}
     * @public
     * @memberof Metrics
     */

  }, {
    key: "initMediaPayload",
    value: function initMediaPayload(eventType, identifiers, options) {
      var payload = {
        eventId: _uuid.default.v4(),
        version: 1,
        origin: {
          buildType: 'prod',
          name: 'endpoint',
          networkType: 'unknown',
          // TODO: check if we can get mediaType
          userAgent: this.userAgentToString(),
          clientInfo: {
            clientType: options.clientType,
            // TODO: Only clientType: 'TEAMS_CLIENT' is whitelisted
            os: 'linux' || this.osName(),
            // TODO: For some reason Mqa does not accept mac
            osVersion: _bowser.default.osVersion || 'unknown',
            subClientType: options.subClientType
          }
        },
        originTime: {
          triggered: new Date().toISOString()
        },
        event: {
          name: eventType,
          canProceed: true,
          identifiers: identifiers,
          intervals: [options.intervalData],
          eventData: {
            webClientDomain: _window.default.location.hostname
          },
          sourceMetadata: {
            applicationSoftwareType: 'webex-js-sdk',
            applicationSoftwareVersion: this.webex.version,
            mediaEngineSoftwareType: _bowser.default.name || 'browser',
            mediaEngineSoftwareVersion: _bowser.default.osVersion || 'unknown',
            startTime: new Date().toISOString()
          }
        }
      };
      return payload;
    }
    /*
     * This function Parses a Locus error and returns a diagnostic event payload.
     * It should keep updating from:
     * https://sqbu-github.cisco.com/WebExSquared/spark-client-framework/blob/master/spark-client-framework/Adapters/TelephonyAdapter/TelephonyAdapter.cpp#L920
     * @param err {Object} the error Object from Locus response
     * @param {boolean} showToUser true if a toast is shown to user
     * @returns {{showToUser: boolean, category: string, errorDescription: string,
     *  errorCode: number, errorData: *, fatal: boolean, name: string}}
     */

  }, {
    key: "parseLocusError",
    value: function parseLocusError(err, showToUser) {
      var errorCode;

      if (err && err.body && err.body.errorCode) {
        switch (_config2.errorCodes[err.body.errorCode]) {
          case _constants.MEETING_ERRORS.FREE_USER_MAX_PARTICIPANTS_EXCEEDED:
            errorCode = 3007;
            break;

          case _constants.MEETING_ERRORS.PAID_USER_MAX_PARTICIPANTS_EXCEEDED:
          case _constants.MEETING_ERRORS.SERVICE_MAX_PARTICIPANTS_EXCEEDED:
            errorCode = 3002;
            break;

          case _constants.MEETING_ERRORS.INACTIVE:
            errorCode = 4001;
            break;

          case _constants.MEETING_ERRORS.EXCEEDED_MAX_JOINED_PARTICIPANTS:
          case _constants.MEETING_ERRORS.EXCEEDED_SERVICE_MAX_PARTICIPANTS:
            errorCode = 3001;
            break;

          case _constants.MEETING_ERRORS.MEETING_IS_LOCKED:
            errorCode = 4002;
            break;

          case _constants.MEETING_ERRORS.MEETING_IS_TERMINATING:
            errorCode = 4003;
            break;

          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN_INTENT:
            errorCode = 4004;
            break;

          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN:
            errorCode = 4005;
            break;

          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_ROLE:
            errorCode = 4006;
            break;

          case _constants.MEETING_ERRORS.JOIN_RESTRICTED_USER:
          case _constants.MEETING_ERRORS.GET_RESTRICTED_USER:
          case _constants.MEETING_ERRORS.CREATE_MEDIA_RESTRICTED_USER:
            errorCode = 3005;
            break;

          case _constants.MEETING_ERRORS.JOIN_RESTRICTED_USER_NOT_IN_ROOM:
            errorCode = 4007;
            break;

          case _constants.MEETING_ERRORS.MEETING_NOT_FOUND:
            errorCode = 4011;
            break;

          case _constants.MEETING_ERRORS.NOT_WEBEX_SITE:
            errorCode = 4012;
            break;

          case _constants.MEETING_ERRORS.INVALID_JOIN_TIME:
            errorCode = 4013;
            break;

          case _constants.MEETING_ERRORS.PHONE_NUMBER_NOT_A_NUMBER:
            errorCode = 4016;
            break;

          case _constants.MEETING_ERRORS.PHONE_NUMBER_TOO_LONG:
            errorCode = 4017;
            break;

          case _constants.MEETING_ERRORS.INVALID_DIALABLE_KEY:
            errorCode = 4018;
            break;

          case _constants.MEETING_ERRORS.ONE_ON_ONE_TO_SELF_NOT_ALLOWED:
            errorCode = 4019;
            break;

          case _constants.MEETING_ERRORS.REMOVED_PARTICIPANT:
            errorCode = 4020;
            break;

          case _constants.MEETING_ERRORS.MEETING_LINK_NOT_FOUND:
            errorCode = 4021;
            break;

          case _constants.MEETING_ERRORS.PHONE_NUMBER_TOO_SHORT_AFTER_IDD:
            errorCode = 4022;
            break;

          case _constants.MEETING_ERRORS.INVALID_INVITEE_ADDRESS:
            errorCode = 4023;
            break;

          case _constants.MEETING_ERRORS.PMR_ACCOUNT_LOCKED:
            errorCode = 4024;
            break;

          case _constants.MEETING_ERRORS.RESOURCE_GUEST_FORBIDDEN:
            errorCode = 4025;
            break;

          case _constants.MEETING_ERRORS.PMR_ACCOUNT_SUSPENDED:
            errorCode = 4026;
            break;

          case _constants.MEETING_ERRORS.EMPTY_PHONE_NUMBER_OR_COUNTRY_CODE:
            errorCode = 4027;
            break;

          case _constants.MEETING_ERRORS.INVALID_SINCE_OR_SEQUENCE_HASH_IN_REQUEST:
            errorCode = 1006;
            break;

          case _constants.MEETING_ERRORS.CONVERSATION_NOT_FOUND:
            errorCode = 4028;
            break;

          case _constants.MEETING_ERRORS.RECORDING_CONTROL_NOT_SUPPORTED:
          case _constants.MEETING_ERRORS.RECORDING_NOT_STARTED:
          case _constants.MEETING_ERRORS.RECORDING_NOT_ENABLED:
            errorCode = 4029;
            break;

          default:
            errorCode = 4008;
        }
      } else {
        errorCode = 4008;
      }

      return this.generateErrorPayload(errorCode, showToUser, _config2.error.name.LOCUS_RESPONSE, err);
    }
  }, {
    key: "generateErrorPayload",
    value: function generateErrorPayload(errorCode, shownToUser, name, err) {
      if (_config2.error.errors[errorCode]) {
        var errorPayload = {
          shownToUser: shownToUser || false,
          category: _config2.error.errors[errorCode][2],
          errorDescription: _config2.error.errors[errorCode][0],
          errorCode: errorCode,
          fatal: !(0, _includes2.default)(_config2.error.notFatalErrorList, errorCode),
          name: name || _config2.error.name.OTHER
        };

        if (err && err.body) {
          errorPayload.errorData = err.body;
        }

        return errorPayload;
      }

      return null;
    }
    /**
     * Returns a formated string of the user agent.
     *
     * @returns {string} formatted user agent information
     */

  }, {
    key: "userAgentToString",
    value: function userAgentToString() {
      var userAgentOption;
      var browserInfo;
      var osInfo;

      var clientInfo = _util.default.format('client=%s', "".concat(_config.default.meetings.metrics.clientName));

      if (_bowser.default.name && ['chrome', 'firefox', 'msie', 'msedge', 'safari'].indexOf(_bowser.default.name.toLowerCase()) !== -1 && _bowser.default.version) {
        browserInfo = _util.default.format('browser=%s', "".concat(_bowser.default.name.toLowerCase(), "/").concat(_bowser.default.version.split('.')[0]));
      }

      if (_bowser.default.osname && _bowser.default.osversion) {
        osInfo = _util.default.format('os=%s', "".concat(_bowser.default.osname, "/").concat(_bowser.default.osversion.split('.')[0]));
      }

      if (browserInfo) {
        userAgentOption = "(".concat(browserInfo);
      }

      if (osInfo) {
        userAgentOption = userAgentOption ? "".concat(userAgentOption, "; ").concat(clientInfo, "; ").concat(osInfo) : "".concat(clientInfo, "; (").concat(osInfo);
      }

      if (userAgentOption) {
        userAgentOption += ')';
        return _util.default.format('webex-js-sdk/%s %s', "".concat(process.env.NODE_ENV, "-").concat(this.webex.version), userAgentOption);
      }

      return _util.default.format('webex-js-sdk/%s', "".concat(process.env.NODE_ENV, "-").concat(this.webex.version));
    }
    /**
     * Uploads given metric to the Metrics service as an operational metric.
     * Metadata about the environment such as browser, OS, SDK and their versions
     * are automatically added when the metric is sent.
     *
     * The Metrics service will send an operational metric to InfluxDB for
     * aggregation.
     * See https://confluence-eng-gpk2.cisco.com/conf/display/WBXT/Getting+started+with+Metrics+Service.
     *
     * @param {string} metricName  Name of the metric (measurement) to send
     * @param {Object} metricFields  Key-valye pairs of data or values about this metric
     * @param {Object} metricTags  Key-value pairs of metric metadata
     *
     * @returns {void}
     */

  }, {
    key: "sendOperationalMetric",
    value: function sendOperationalMetric(metricName) {
      var metricFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var metricTags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var fields = _objectSpread(_objectSpread({}, metricFields), {}, {
        browser_version: _bowser.default.version,
        os_version: _bowser.default.osversion,
        sdk_version: this.webex.version
      });

      var tags = _objectSpread(_objectSpread({}, metricTags), {}, {
        browser: _bowser.default.name,
        org_id: this.webex.credentials.getOrgId(),
        os: _bowser.default.osname,
        domain: _window.default.location.hostname,
        client_id: this.webex.credentials.config.client_id
      });

      if (!metricName) {
        throw Error('Missing operational metric name. Please provide one');
      }

      this.webex.internal.metrics.submitClientMetrics(metricName, {
        type: ['operational'],
        fields: fields,
        tags: tags
      });
    }
  }]);
  return Metrics;
}(); // Export Metrics singleton ---------------------------------------------------


var instance = new Metrics();
var _default = instance;
exports.default = _default;
//# sourceMappingURL=index.js.map
