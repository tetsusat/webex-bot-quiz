"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _construct = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/construct"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _uuid = _interopRequireDefault(require("uuid"));

var _webexCore = require("@webex/webex-core");

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = (0, _construct.default)(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_construct.default) return false; if (_construct.default.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call((0, _construct.default)(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class MeetingRequest
 */
var MeetingRequest = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(MeetingRequest, _StatelessWebexPlugin);

  var _super = _createSuper(MeetingRequest);

  function MeetingRequest() {
    (0, _classCallCheck2.default)(this, MeetingRequest);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(MeetingRequest, [{
    key: "joinMeeting",

    /**
     * Make a network request to join a meeting
     * @param {Object} options
     * @param {String} options.sipUri
     * @param {String} options.deviceUrl
     * @param {String} options.locusUrl
     * @param {String} options.resourceId,
     * @param {String} options.correlationId
     * @param {boolean} options.ensureConversation
     * @param {boolean} options.moderator
     * @param {boolean} options.pin
     * @param {boolean} options.moveToResource
     * @param {Object} options.roapMessage
     * @returns {Promise}
     */
    value: function () {
      var _joinMeeting = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(options) {
        var sipUri, deviceUrl, locusUrl, resourceId, correlationId, ensureConversation, moderator, pin, moveToResource, roapMessage, preferTranscoding, url, body;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                sipUri = options.sipUri, deviceUrl = options.deviceUrl, locusUrl = options.locusUrl, resourceId = options.resourceId, correlationId = options.correlationId, ensureConversation = options.ensureConversation, moderator = options.moderator, pin = options.pin, moveToResource = options.moveToResource, roapMessage = options.roapMessage, preferTranscoding = options.preferTranscoding;

                _loggerProxy.default.logger.info('Meeting:request#joinMeeting --> Joining a meeting', correlationId);

                url = '';
                body = {
                  device: {
                    url: deviceUrl,
                    deviceType: this.config.meetings.deviceType
                  },
                  usingResource: resourceId || null,
                  moveMediaToResource: resourceId && moveToResource || false,
                  correlationId: correlationId,
                  respOnlySdp: true,
                  allowMultiDevice: true,
                  ensureConversation: ensureConversation || false,
                  supportsNativeLobby: 1,
                  clientMediaPreferences: {
                    preferTranscoding: preferTranscoding !== null && preferTranscoding !== void 0 ? preferTranscoding : true
                  }
                };

                if (moderator !== undefined) {
                  body.moderator = moderator;
                }

                if (pin !== undefined) {
                  body.pin = pin;
                }

                if (!locusUrl) {
                  _context.next = 10;
                  break;
                }

                url = "".concat(locusUrl, "/").concat(_constants.PARTICIPANT);
                _context.next = 22;
                break;

              case 10:
                if (!sipUri) {
                  _context.next = 22;
                  break;
                }

                _context.prev = 11;
                _context.next = 14;
                return this.webex.internal.services.waitForCatalog('postauth');

              case 14:
                url = "".concat(this.webex.internal.services.get('locus'), "/").concat(_constants.LOCI, "/").concat(_constants.CALL);
                body.invitee = {
                  address: sipUri
                };
                _context.next = 22;
                break;

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](11);

                _loggerProxy.default.logger.error("Meeting:request#joinMeeting --> ".concat(_context.t0));

                throw _context.t0;

              case 22:
                // TODO: -- this will be resolved in SDK request
                url = url.concat("?".concat(_constants.ALTERNATE_REDIRECT_TRUE));

                if (resourceId === sipUri) {
                  body.callPreferences = {
                    requestedMedia: [_constants._SLIDES_]
                  };
                }

                if (roapMessage) {
                  body.localMedias = roapMessage.localMedias;
                }

                return _context.abrupt("return", this.webex.request({
                  method: _constants.HTTP_VERBS.POST,
                  uri: url,
                  body: body
                }));

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[11, 18]]);
      }));

      function joinMeeting(_x) {
        return _joinMeeting.apply(this, arguments);
      }

      return joinMeeting;
    }()
    /**
     * Syns the missed delta event
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.syncUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: "syncMeeting",
    value: function syncMeeting(options) {
      /* eslint-disable no-else-return */
      var desync = options.desync;
      var syncUrl = options.syncUrl;
      /* istanbul ignore else */

      if (desync) {
        // check for existing URL parameters
        syncUrl = syncUrl.concat(syncUrl.split('?')[1] ? '&' : '?').concat("".concat(_constants.LOCUS.SYNCDEBUG, "=").concat(desync));
      }

      return this.request({
        method: _constants.HTTP_VERBS.GET,
        uri: syncUrl
      }) // TODO: Handle if delta sync failed . Get the full locus object
      .catch(function (err) {
        _loggerProxy.default.logger.error("Meeting:request#syncMeeting --> Error syncing meeting, error ".concat(err));

        return err;
      });
    }
    /**
     * Request to get the complete locus object
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.locusUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: "getFullLocus",
    value: function getFullLocus(options) {
      var locusUrl = options.locusUrl;
      var desync = options.desync;

      if (locusUrl) {
        if (desync) {
          locusUrl += "?".concat(_constants.LOCUS.SYNCDEBUG, "=").concat(desync);
        }

        return this.request({
          method: _constants.HTTP_VERBS.GET,
          uri: locusUrl
        }).catch(function (err) {
          _loggerProxy.default.logger.error("Meeting:request#getFullLocus --> Error getting full locus, error ".concat(err));

          return err;
        });
      }

      return _promise.default.reject();
    }
    /**
     * Make a network request to leave a meeting
     * @param {Object} options
     * @param {Url} options.locusUrl
     * @param {String} options.selfId
     * @param {Url} options.deviceUrl
     * @param {String} options.resourceId,
     * @param {String} options.correlationId
     * @returns {Promise}
     */

  }, {
    key: "leaveMeeting",
    value: function leaveMeeting(_ref) {
      var locusUrl = _ref.locusUrl,
          selfId = _ref.selfId,
          url = _ref.deviceUrl,
          resourceId = _ref.resourceId,
          correlationId = _ref.correlationId;

      _loggerProxy.default.logger.info('Meeting:request#leaveMeeting --> Leaving a meeting', correlationId);

      var uri = "".concat(locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(selfId, "/").concat(_constants.LEAVE);
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: url
        },
        usingResource: resourceId || null,
        correlationId: correlationId
      };
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * Make a network request to acknowledge a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.id
     * @returns {Promise}
     */

  }, {
    key: "acknowledgeMeeting",
    value: function acknowledgeMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(_constants.ALERT);
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        correlationId: options.id
      };
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * Make a network request to acknowledge a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.id
     * @returns {Promise}
     */

  }, {
    key: "recordMeeting",
    value: function recordMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.CONTROLS);
      var body = {
        record: {
          recording: options.recording,
          paused: options.paused
        }
      };
      return this.request({
        method: _constants.HTTP_VERBS.PATCH,
        uri: uri,
        body: body
      });
    }
  }, {
    key: "lockMeeting",
    value: function lockMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.CONTROLS);
      var body = {
        lock: {
          locked: options.lock
        }
      };
      return this.request({
        method: _constants.HTTP_VERBS.PATCH,
        uri: uri,
        body: body
      });
    }
    /**
     * Make a network request to decline a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.reason
     * @returns {Promise}
     */

  }, {
    key: "declineMeeting",
    value: function declineMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(_constants.DECLINE);
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        reason: options.reason
      };
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * Toggle remote audio and/or video
     * @param {Object} options options for toggling
     * @param {String} options.selfId Locus self id??
     * @param {String} options.locusUrl Locus url
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.localMedias local sdps
     * @returns {Promise}
     */

  }, {
    key: "remoteAudioVideoToggle",
    value: function remoteAudioVideoToggle(options) {
      var _options$preferTransc;

      var uri = "".concat(options.locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(options.selfId, "/").concat(_constants.MEDIA);
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        usingResource: options.resourceId || null,
        correlationId: options.correlationId,
        respOnlySdp: true,
        localMedias: options.localMedias,
        clientMediaPreferences: {
          preferTranscoding: (_options$preferTransc = options.preferTranscoding) !== null && _options$preferTransc !== void 0 ? _options$preferTransc : true
        }
      };
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * change the content floor grant
     * @param {Object} options options for floor grant
     * @param {String} options.disposition floor action (granted/released)
     * @param {String} options.personUrl personUrl who is requesting floor
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.uri floor grant uri
     * @returns {Promise}
     */

  }, {
    key: "changeMeetingFloor",
    value: function changeMeetingFloor(options) {
      var floorReq = {
        disposition: options.disposition
      };
      /* istanbul ignore else */

      if (options.disposition === _constants.FLOOR_ACTION.GRANTED) {
        floorReq = {
          beneficiary: {
            url: options.personUrl,
            devices: [{
              deviceType: this.config.meetings.deviceType,
              url: options.deviceUrl
            }]
          },
          disposition: options.disposition,
          requester: {
            url: options.personUrl
          }
        };
      }

      return this.request({
        uri: options.uri,
        method: _constants.HTTP_VERBS.PUT,
        body: {
          floor: floorReq,
          resourceUrl: options.resourceUrl
        }
      });
    }
    /**
     * Sends a request to the DTMF endpoint to send tones
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.tones a string of one or more DTMF tones to send
     * @returns {Promise}
     */

  }, {
    key: "sendDTMF",
    value: function sendDTMF(_ref2) {
      var locusUrl = _ref2.locusUrl,
          deviceUrl = _ref2.deviceUrl,
          tones = _ref2.tones;
      return this.request({
        method: _constants.HTTP_VERBS.POST,
        uri: "".concat(locusUrl, "/").concat(_constants.SEND_DTMF_ENDPOINT),
        body: {
          deviceUrl: deviceUrl,
          dtmf: {
            correlationId: _uuid.default.v4(),
            tones: tones
          }
        }
      });
    }
    /**
     * Sends a request to the controls endpoint to set the video layout
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.layoutType a layout type that should be available in meeting constants LAYOUT_TYPES
     * @returns {Promise}
     */

  }, {
    key: "changeVideoLayout",
    value: function changeVideoLayout(_ref3) {
      var locusUrl = _ref3.locusUrl,
          deviceUrl = _ref3.deviceUrl,
          layoutType = _ref3.layoutType;
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: "".concat(locusUrl, "/").concat(_constants.CONTROLS),
        body: {
          layout: {
            deviceUrl: deviceUrl,
            type: layoutType
          }
        }
      });
    }
  }]);
  return MeetingRequest;
}(_webexCore.StatelessWebexPlugin);

exports.default = MeetingRequest;
//# sourceMappingURL=request.js.map
