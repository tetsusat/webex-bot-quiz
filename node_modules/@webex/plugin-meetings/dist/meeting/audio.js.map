{"version":3,"sources":["audio.js"],"names":["handleTransition","audio","mute","self","MEETING_AUDIO_STATE_MACHINE","STATES","MUTE_SELF","UNMUTE_SELF","doToggle","transition","meeting","Media","setLocalTrack","mediaProperties","audioTrack","meetingVideo","video","videoMuted","muted","MeetingUtil","remoteUpdateAudioVideo","then","LoggerProxy","logger","log","event","from","to","catch","remoteUpdateError","reject","AudioStateMachine","create","mediaDirection","sendAudio","StateMachine","transitions","name","TRANSITIONS","TOGGLE","state","data","methods","isMuted","isSelf","setData","onBeforeToggle","resolve","onAfterToggle","plugins","StateMachineHistory","max"],"mappings":"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","sourcesContent":["import StateMachine from 'javascript-state-machine';\nimport StateMachineHistory from 'javascript-state-machine/lib/history';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Media from '../media';\nimport MeetingUtil from '../meeting/util';\nimport {MEETING_AUDIO_STATE_MACHINE} from '../constants';\n\nconst handleTransition = (audio) => {\n  if (audio.mute && audio.self) {\n    return MEETING_AUDIO_STATE_MACHINE.STATES.MUTE_SELF;\n  }\n  if (!audio.mute && audio.self) {\n    return MEETING_AUDIO_STATE_MACHINE.STATES.UNMUTE_SELF;\n  }\n\n  return null;\n};\n\nconst doToggle = (transition, audio, meeting) => {\n  Media.setLocalTrack(audio.mute, meeting.mediaProperties.audioTrack);\n  const meetingVideo = meeting.video;\n  const videoMuted = meetingVideo ? meetingVideo.muted : true;\n\n  return MeetingUtil.remoteUpdateAudioVideo(audio.mute, videoMuted, meeting)\n    .then(() => {\n      LoggerProxy.logger.log(\n        `Meeting:audio#doToggle --> AudioStateMachine->onAfterToggle#${transition.event} fired! State changed from '${transition.from}' to '${\n          transition.to\n        }' with transition '${transition.transition}''.`\n      );\n    })\n    .catch((remoteUpdateError) => {\n      LoggerProxy.logger.log(\n        `Meeting:audio#doToggle --> AudioStateMachine->onBeforeToggle#${transition.event} fired! State failed to change with transition '${\n          transition.transition\n        }''. After local audio toggle failed, resetting remote also failed, meeting audio in bad state with error: ${remoteUpdateError}.`\n      );\n\n      return Promise.reject(remoteUpdateError);\n    });\n};\n\nconst AudioStateMachine = {\n  /**\n   *\n   * @param {Object} mediaDirection An object that contains whether we send audio/video/screen streams\n   * @param {Meeting} meeting the meeting instance we are using for this state machine\n   * @returns {StateMachine} returns a StateMachine instance\n   */\n  create(mediaDirection, meeting) {\n    if (!mediaDirection.sendAudio) {\n      return null;\n    }\n\n    return new StateMachine({\n      transitions: [\n        {\n          name: MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.TOGGLE,\n          from: '*',\n          /**\n           *\n           * @param {Object} audio The audio options\n           * @param {Boolean} audio.mute Whether to mute the meeting or not\n           * @param {Boolean} audio.self Whether the was muted by the end user\n           * @param {Boolean} audio.remote Whether the meeting was muted by the server\n           * @returns {String} returns a new value to set the state to\n           */\n          to(audio) {\n            return handleTransition(audio) || this.state;\n          }\n        }\n      ],\n      data: {\n        muted: false,\n        self: true\n      },\n      methods: {\n        /**\n         * Convenience method to return whether the call is muted or not\n         * @returns {Boolen} whether the audio is muted or not\n         */\n        isMuted() {\n          return this.muted;\n        },\n\n        /**\n         * Convenience method to expose this.self\n         * @returns {Boolen} this.self\n         */\n        isSelf() {\n          return this.self;\n        },\n\n        /**\n         *\n         * @param {Object} audio the audio state to change\n         * @returns {null}\n         */\n        setData(audio) {\n          this.muted = audio.mute;\n          this.self = audio.self;\n        },\n\n        /**\n         * Method that gets fired before the toggle state change.\n         * If this fails, return false will cancel the transition and the state will remain unchanged\n         * @param {Object} transition the StateMachine transition object\n         * @param {Object} audio Audio options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onBeforeToggle(transition, audio) {\n          if (transition.from !== transition.to) {\n            return doToggle(transition, audio, meeting)\n              .then(() => Promise.resolve(this.data));\n          }\n\n          return Promise.resolve(this.data);\n        },\n\n        /**\n         *\n         * @param {Object} transition StateMachine transition\n         * @param {Object} audio audio options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onAfterToggle(transition, audio) {\n          this.setData(audio);\n\n          return Promise.resolve(this.data);\n        },\n        plugins: [new StateMachineHistory({max: 5})]\n      }\n    });\n  }\n};\n\nexport default AudioStateMachine;\n"]}