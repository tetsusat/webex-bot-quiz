"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _javascriptStateMachine = _interopRequireDefault(require("javascript-state-machine"));

var _history = _interopRequireDefault(require("javascript-state-machine/lib/history"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _media = _interopRequireDefault(require("../media"));

var _util = _interopRequireDefault(require("../meeting/util"));

var _constants = require("../constants");

var handleTransition = function handleTransition(audio) {
  if (audio.mute && audio.self) {
    return _constants.MEETING_AUDIO_STATE_MACHINE.STATES.MUTE_SELF;
  }

  if (!audio.mute && audio.self) {
    return _constants.MEETING_AUDIO_STATE_MACHINE.STATES.UNMUTE_SELF;
  }

  return null;
};

var doToggle = function doToggle(transition, audio, meeting) {
  _media.default.setLocalTrack(audio.mute, meeting.mediaProperties.audioTrack);

  var meetingVideo = meeting.video;
  var videoMuted = meetingVideo ? meetingVideo.muted : true;
  return _util.default.remoteUpdateAudioVideo(audio.mute, videoMuted, meeting).then(function () {
    _loggerProxy.default.logger.log("Meeting:audio#doToggle --> AudioStateMachine->onAfterToggle#".concat(transition.event, " fired! State changed from '").concat(transition.from, "' to '").concat(transition.to, "' with transition '").concat(transition.transition, "''."));
  }).catch(function (remoteUpdateError) {
    _loggerProxy.default.logger.log("Meeting:audio#doToggle --> AudioStateMachine->onBeforeToggle#".concat(transition.event, " fired! State failed to change with transition '").concat(transition.transition, "''. After local audio toggle failed, resetting remote also failed, meeting audio in bad state with error: ").concat(remoteUpdateError, "."));

    return _promise.default.reject(remoteUpdateError);
  });
};

var AudioStateMachine = {
  /**
   *
   * @param {Object} mediaDirection An object that contains whether we send audio/video/screen streams
   * @param {Meeting} meeting the meeting instance we are using for this state machine
   * @returns {StateMachine} returns a StateMachine instance
   */
  create: function create(mediaDirection, meeting) {
    if (!mediaDirection.sendAudio) {
      return null;
    }

    return new _javascriptStateMachine.default({
      transitions: [{
        name: _constants.MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.TOGGLE,
        from: '*',

        /**
         *
         * @param {Object} audio The audio options
         * @param {Boolean} audio.mute Whether to mute the meeting or not
         * @param {Boolean} audio.self Whether the was muted by the end user
         * @param {Boolean} audio.remote Whether the meeting was muted by the server
         * @returns {String} returns a new value to set the state to
         */
        to: function to(audio) {
          return handleTransition(audio) || this.state;
        }
      }],
      data: {
        muted: false,
        self: true
      },
      methods: {
        /**
         * Convenience method to return whether the call is muted or not
         * @returns {Boolen} whether the audio is muted or not
         */
        isMuted: function isMuted() {
          return this.muted;
        },

        /**
         * Convenience method to expose this.self
         * @returns {Boolen} this.self
         */
        isSelf: function isSelf() {
          return this.self;
        },

        /**
         *
         * @param {Object} audio the audio state to change
         * @returns {null}
         */
        setData: function setData(audio) {
          this.muted = audio.mute;
          this.self = audio.self;
        },

        /**
         * Method that gets fired before the toggle state change.
         * If this fails, return false will cancel the transition and the state will remain unchanged
         * @param {Object} transition the StateMachine transition object
         * @param {Object} audio Audio options
         * @returns {Object} this.data which contains {muted, self}
         */
        onBeforeToggle: function onBeforeToggle(transition, audio) {
          var _this = this;

          if (transition.from !== transition.to) {
            return doToggle(transition, audio, meeting).then(function () {
              return _promise.default.resolve(_this.data);
            });
          }

          return _promise.default.resolve(this.data);
        },

        /**
         *
         * @param {Object} transition StateMachine transition
         * @param {Object} audio audio options
         * @returns {Object} this.data which contains {muted, self}
         */
        onAfterToggle: function onAfterToggle(transition, audio) {
          this.setData(audio);
          return _promise.default.resolve(this.data);
        },
        plugins: [new _history.default({
          max: 5
        })]
      }
    });
  }
};
var _default = AudioStateMachine;
exports.default = _default;
//# sourceMappingURL=audio.js.map
